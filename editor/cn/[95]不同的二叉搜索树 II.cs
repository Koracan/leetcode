//ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¯·ä½ ç”Ÿæˆå¹¶è¿”å›æ‰€æœ‰ç”± n ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» 1 åˆ° n äº’ä¸ç›¸åŒçš„ä¸åŒ äºŒå‰æœç´¢æ ‘ ã€‚å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚ 
//
// 
//
// 
// 
// ç¤ºä¾‹ 1ï¼š 
// 
// 
//è¾“å…¥ï¼šn = 3
//è¾“å‡ºï¼š[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
// 
// 
// 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šn = 1
//è¾“å‡ºï¼š[[1]]
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// 1 <= n <= 8 
// 
//
// Related Topics æ ‘ äºŒå‰æœç´¢æ ‘ åŠ¨æ€è§„åˆ’ å›æº¯ äºŒå‰æ ‘ ğŸ‘ 1615 ğŸ‘ 0

namespace UniqueBinarySearchTreesIi;

//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * public int val;
 * public TreeNode left;
 * public TreeNode right;
 * public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
public class Solution
{
    public IList<TreeNode> GenerateTrees(int n)
    {
        var memory = new List<TreeNode?>?[n + 1, n + 1];
        return Generate(1, n)!;

        List<TreeNode?> Generate(int start, int end)
        {
            if (start > end) return [null];
            if (memory[start, end] != null) return memory[start, end]!;
            if (start == end) {
                memory[start, end] = [new(start)];
                return memory[start, end]!;
            }

            var result = new List<TreeNode?>();
            for (var mid = start; mid <= end; mid++)
                foreach (var left in Generate(start, mid - 1))
                    foreach (var right in Generate(mid + 1, end))
                        result.Add(new(mid, left, right));


            memory[start, end] = result;
            return result;
        }
    }
}

//leetcode submit region end(Prohibit modification and deletion)
public class TreeNode(int val = 0, TreeNode? left = null, TreeNode? right = null)
{
    public TreeNode? left = left;
    public TreeNode? right = right;
    public int val = val;
}
